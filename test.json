"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.7.0 <0.9.0;\n\nlibrary Types {\n    /*\ntypes:\n\n    date =  uint32 (max year 10,141), UNIX minutes\n  amount =  uint80 1 unit = 1000 wei,  (max 1e27 GWei or 1,208,925,819 units) \n   ratio =  uint16 (max 65536)\n    time =  uint16 (max 45 days), minutes\n account = uint160 (max 20 digits bank account)\n   nonce =  uint48 (max 6 characters SPEI nonce)\n*/\n\n    /** Order fixed data, 256 bits */\n    struct Order {\n        /** dest account */\n        uint160 dest;\n        /** SPEI nonce */\n        uint48 nonce;\n        /** \n            Coin price in COIN units (1e18 wei) / (MXN * 1000)\n            thus, \n                if ratio is \n                [1,1] -> 1 token = 1000 MXN,\n                [2,1] -> 1 token = 2000 MXN ,\n            [1, 1000] -> 1 token =    1 MXN\n                    \n        */\n        uint16 priceMXN1000Num;\n        uint16 priceMXN1000Den;\n        /** Max public key index for this order, this prevents validating signatures for a seller-untrusted public key */\n        uint16 maxPubKeyIndex;\n    }\n\n    /** Order variable info, 232 bits */\n    struct OrderVariables {\n        /**Order total funds */\n        uint80 funds;\n        /** Order locked funds */\n        uint80 locked;\n        /**Date at which the lock expires */\n        uint32 expire;\n        /** True to disable order locking */\n        bool disabled;\n        /** \n    Lock ratio in 1 / 10000 units, cost / amount indicates buyer needs to pay \"cost\" in order to lock \"amount\" funds\n    The lock is free if cost == 0 \n     */\n        uint16 lockRatio10000;\n        /** Lock time in minutes */\n        uint16 lockTime;\n        /** Order coin */\n        uint16 coinIndex;\n    }\n\n    /** Order lock per buyer, 112 bits */\n    struct BuyerLock {\n        /** Order locked funds */\n        uint80 amount;\n        /**Date at which the lock expires */\n        uint32 expire;\n        /** Date at which the lock started, used to calculate public key enable state */\n        uint32 publicKeyDateRef;\n    }\n\n    struct PublicKey {\n        uint256 exp;\n        uint256[8] modulus;\n        /** Public key will be enabled at this time */\n        uint32 enableTime;\n        /** Public key will be disabled at this time */\n        uint32 disableTime;\n    }\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP\n */\n\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n\nlibrary Utils {\n    function mulRatio(\n        uint80 amount,\n        uint16 ratioNum,\n        uint16 ratioDen\n    ) internal pure returns (uint80) {\n        return uint80((uint256(amount) * ratioNum) / ratioDen);\n    }\n\n    /** \n        Converts from MXN cents to 1000 wei units\n        Price is in \n     */\n    function MxnCentsTo1000Wei(\n        uint80 amountMXN,\n        uint16 priceMXN1000Num,\n        uint16 priceMXN1000Den\n    ) internal pure returns (uint80) {\n        return\n            uint80(\n                (uint256(amountMXN) * priceMXN1000Den * 10000000000) /\n                    priceMXN1000Num\n            );\n    }\n\n    function addRatio(\n        uint80 amount,\n        uint16 ratioNum,\n        uint16 ratioDen\n    ) internal pure returns (uint80) {\n        return uint80(amount + ((uint256(amount) * ratioNum) / ratioDen));\n    }\n\n    /** Returns an order locked funds or 0 if the lock is expired */\n    function getLockedAmount(\n        uint80 locked,\n        uint32 lockExpire,\n        uint32 nowMinutes\n    ) internal pure returns (uint80 ret) {\n        assembly {\n            ret := mul(locked, lt(nowMinutes, lockExpire))\n        }\n    }\n\n    function min(uint80 a, uint80 b) internal pure returns (uint80) {\n        return a < b ? a : b;\n    }\n\n    function min(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a < b ? a : b;\n    }\n}\n\ncontract UtilsTest {\n    function MxnCentsTo1000Wei(\n        uint80 amountMXN,\n        uint16 priceMXN1000Num,\n        uint16 priceMXN1000Den\n    ) external pure returns (uint80) {\n        return\n            Utils.MxnCentsTo1000Wei(\n                amountMXN,\n                priceMXN1000Num,\n                priceMXN1000Den\n            );\n    }\n}\n\n\n\nlibrary Buy {\n    /** Returns how much a buyer will get if a buy with the given MXN amount is executed\n        considering buyer locks\n     */\n    function calcBuyAmount(\n        uint80 bLock,\n        uint80 amountMXN,\n        uint16 priceMXNNum,\n        uint16 priceMXNDen,\n        uint16 lockRatio10000\n    ) internal pure returns (uint80) {\n        return Utils.min(\n            Utils.addRatio(\n                Utils.MxnCentsTo1000Wei(amountMXN, priceMXNNum, priceMXNDen),\n                lockRatio10000, \n                10000\n            )\n            , bLock);\n    }\n\n    /** \n        Executes an already verified buy, returns the buy amount and fee in token units.\n        Considers buyer lock amount\n    */\n    function executeBuy(\n        mapping(uint256 => Types.OrderVariables) storage orderVars,\n        mapping(address => uint256) storage ownerFees,\n        mapping(uint16 => address) storage coins,\n        mapping(address => mapping(uint256 => Types.BuyerLock)) storage buyerLocks,\n        Types.BuyerLock memory buyerLock,\n        uint256 orderIndex,\n        uint80 amountMXN,\n        uint16 priceMXNNum,\n        uint16 priceMXNDen,\n        uint8 ownerFeeRatio\n    ) internal returns (uint80) {\n        require(amountMXN > 0, \"amount is 0\");\n\n        uint80 bLock;\n        {\n            bLock = Utils.getLockedAmount(\n                buyerLock.amount,\n                buyerLock.expire,\n                uint32(block.timestamp / 60)\n            );\n        }\n\n        require(bLock > 0, \"no buyer lock\");\n\n        Types.OrderVariables memory order = orderVars[orderIndex];\n\n        uint80 amount = calcBuyAmount(\n            bLock,\n            amountMXN,\n            priceMXNNum,\n            priceMXNDen,\n            order.lockRatio10000\n        );\n\n        if (amount == 0) return 0;\n        {\n            address coin = coins[order.coinIndex];\n            uint80 fee = amount * ownerFeeRatio / 1000;\n            if(fee > 0) {\n                ownerFees[coin] += fee;\n            }\n            if (!IERC20(coin).transfer(msg.sender, uint256(amount - fee) * 1000)) {\n                // unreachable\n                revert(\"not enough balance in contract\");\n            }\n        }\n\n        orderVars[orderIndex] = Types.OrderVariables({\n            // copy\n            expire: order.expire,\n            lockTime: order.lockTime,\n            lockRatio10000: order.lockRatio10000,\n            disabled: order.disabled,\n            coinIndex: order.coinIndex,\n\n            // update\n            funds: order.funds - amount,\n            locked: order.locked - amount\n        });\n\n         buyerLocks[msg.sender][orderIndex] = Types.BuyerLock({\n            // copy:\n            expire: buyerLock.expire,\n            publicKeyDateRef: buyerLock.publicKeyDateRef,\n\n            // update:\n            amount: bLock - amount\n        });\n\n        return amount;\n    }\n}\n\n\n\n\nlibrary Parser {\n    /** \n    Returns the number of days since 1970-01-01\n    Valid in the year range [2001, 2399]\n    */\n    function getUnixDate(\n        uint32 y,\n        uint32 m,\n        uint32 d\n    ) internal pure returns (uint32) {\n        assembly {\n            y := sub(y, lt(m, 3))\n        }\n\n        uint32 yoe = y - 2000; // [0, 399]\n        uint32 doy = ((153 * ((m + 9) % 12) + 2) / 5) + d - 1; // [0, 365]\n        uint32 doe = yoe * 365 + (yoe / 4) - (yoe / 100) + doy; // [0, 146096]\n        return doe + 11017;\n    }\n\n    /** Parses a CEP \"cadenaCDA\" attribute */\n    function parseMessage(string calldata message)\n        external\n        pure\n        returns (\n            uint32 date,\n            uint48 nonce,\n            uint160 dest,\n            uint80 amount\n        )\n    {\n        //parse the date:\n        uint256 dateAscii;\n        assembly {\n            dateAscii := calldataload(add(message.offset, 13))\n        }\n\n        {\n            uint32 day = uint32(\n                (((dateAscii >> 248) & 0x0f) * 10) +\n                    ((dateAscii >> 240) & 0x000f)\n            );\n\n            uint32 month = uint32(\n                (((dateAscii >> 232) & 0x0f) * 10) +\n                    ((dateAscii >> 224) & 0x000f)\n            );\n\n            uint32 year = uint32(\n                (((dateAscii >> 216) & 0x0f) * 1000) +\n                    (((dateAscii >> 208) & 0x000f) * 100) +\n                    (((dateAscii >> 200) & 0x00000f) * 10) +\n                    (((dateAscii >> 192) & 0x0000000f))\n            );\n\n            date = getUnixDate(year, month, day);\n        }\n\n        assembly {\n            let b := add(message.offset, 22)\n            {\n                let pipeCount := 0\n                for {\n\n                } lt(pipeCount, 5) {\n                    b := add(b, 1)\n                } {\n                    // if char is pipe\n                    if eq(\n                        and(\n                            calldataload(b),\n                            0xff00000000000000000000000000000000000000000000000000000000000000\n                        ),\n                        0x7c00000000000000000000000000000000000000000000000000000000000000\n                    ) {\n                        pipeCount := add(pipeCount, 1)\n                    }\n                }\n            }\n\n            // we know that on position 5 we have an account number with at least 12 bytes\n            b := add(b, 12)\n            {\n                let pipeCount := 0\n                for {\n\n                } lt(pipeCount, 5) {\n                    b := add(b, 1)\n                } {\n                    // if char is pipe\n                    if eq(\n                        and(\n                            calldataload(b),\n                            0xff00000000000000000000000000000000000000000000000000000000000000\n                        ),\n                        0x7c00000000000000000000000000000000000000000000000000000000000000\n                    ) {\n                        pipeCount := add(pipeCount, 1)\n                    }\n                }\n            }\n\n            // parse account number:\n            dest := calldataload(b)\n\n            let divisor := 0x100000000000000000000000000000000000000\n            for {\n\n            } iszero(\n                eq(\n                    and(div(dest, divisor), 0xff),\n                    // search the pipe\n                    0x7c\n                )\n            ) {\n\n            } {\n                b := add(b, 1)\n                divisor := div(divisor, 0x100)\n            }\n\n            dest := div(dest, mul(divisor, 0x100))\n\n            b := add(b, 13) // pipe(1) + initial read (11) + pipe (1)\n\n            {\n                //read until the next pipe:\n                for {\n\n                } iszero(\n                    eq(\n                        and(\n                            calldataload(b),\n                            0xff00000000000000000000000000000000000000000000000000000000000000\n                        ),\n                        0x7c00000000000000000000000000000000000000000000000000000000000000\n                    )\n                ) {\n\n                } {\n                    b := add(b, 1)\n                }\n\n                b := add(b, 1) // pipe\n            }\n\n            // parse the nonce\n\n            nonce := div(\n                and(\n                    calldataload(b),\n                    // nonce is 6 digits long\n                    0xffffffffffff0000000000000000000000000000000000000000000000000000\n                ),\n                0x10000000000000000000000000000000000000000000000000000\n            )\n\n            b := add(b, 11) // read(6) + pipe(1) + read(min 4)\n\n            //read until the next pipe:\n            for {\n\n            } iszero(\n                eq(\n                    and(\n                        calldataload(b),\n                        0xff00000000000000000000000000000000000000000000000000000000000000\n                    ),\n                    0x7c00000000000000000000000000000000000000000000000000000000000000\n                )\n            ) {\n\n            } {\n                b := add(b, 1)\n            }\n\n            b := add(b, 1) // +5 pipe count\n\n            // parse amount:\n\n            // parse integer part:\n            let amountData := calldataload(b)\n            amount := 0\n\n            divisor := 0x100000000000000000000000000000000000000000000000000000000000000\n            for {\n\n            } iszero(\n                eq(\n                    and(div(amountData, divisor), 0xff),\n                    // search the decimal dot\n                    0x2e\n                )\n            ) {\n\n            } {\n                amount := add(\n                    mul(amount, 10),\n                    and(div(amountData, divisor), 0x0f)\n                )\n                divisor := div(divisor, 0x100)\n            }\n\n            // parse decimal part:\n            amount := add(\n                mul(amount, 100),\n                add(\n                    mul(and(div(amountData, div(divisor, 0x100)), 0x0f), 10),\n                    and(div(amountData, div(divisor, 0x10000)), 0x0f)\n                )\n            )\n        }\n    }\n\n    // END 2\n}\n\ncontract ParserTest {\n    /** Parses a CEP \"cadenaCDA\" attribute */\n    function parseMessage(string calldata message)\n        external\n        pure\n        returns (\n            uint256 date,\n            uint48 nonce,\n            uint160 dest,\n            uint256 amount\n        )\n    {\n        return Parser.parseMessage(message);\n    }\n\n    /** \n    Returns the number of days since 2000-03-01\n    Only valid since year 2001\n    */\n    function getUnixDate(\n        uint32 y,\n        uint32 m,\n        uint32 d\n    ) external pure returns (uint32) {\n        return Parser.getUnixDate(y, m, d);\n    }\n}\n\n\n\n\nlibrary RSA {\n    /** Verifies a digital signature for an ASCII message */\n    function verifySig2048SHA256(\n        string calldata message,\n        uint256[8] memory sig,\n        uint256 exp,\n        uint256[8] memory modulus\n    ) internal returns (bool) {\n        bytes32 hash = sha256(abi.encodePacked(message));\n        return verifySig2048SHA256(hash, sig, exp, modulus);\n    }\n\n    /** Verifies a digital signature */\n    function verifySig2048SHA256(\n        bytes32 hash,\n        uint256[8] memory sig,\n        uint256 exp,\n        uint256[8] memory modulus\n    ) private returns (bool) {\n        bytes32[8] memory a = pad2048SHA256(hash);\n        bytes32[8] memory b = powMod2048(sig, exp, modulus);\n\n        return (a[0] == b[0] &&\n            a[1] == b[1] &&\n            a[2] == b[2] &&\n            a[3] == b[3] &&\n            a[4] == b[4] &&\n            a[5] == b[5] &&\n            a[6] == b[6] &&\n            a[7] == b[7]);\n    }\n\n    /** Returns the pkcs1_v15 encoded SHA256*/\n    function pad2048SHA256(bytes32 hash)\n        internal\n        pure\n        returns (bytes32[8] memory pointer)\n    {\n        //0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20\n        //\n        assembly {\n            // prefix\n            mstore(\n                pointer,\n                0x0001000000000000000000000000000000000000000000000000000000000000\n            )\n\n            /*\n                const keyLen = 2048 / 8;\n                const hashInfoLen = 19;\n                const hashLen = 256 / 8\n                const onesLen = keyLen - hashInfoLen - hashLen - 3; // 202\n            */\n            // ones:\n            mstore(\n                add(pointer, 2),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF // 32\n            )\n            mstore(\n                add(pointer, 34),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF // 64\n            )\n            mstore(\n                add(pointer, 66),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF // 96\n            )\n            mstore(\n                add(pointer, 98),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF // 128\n            )\n            mstore(\n                add(pointer, 130),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF // 160\n            )\n            mstore(\n                add(pointer, 162),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF // 192\n            )\n\n            // last 10 ones, plus one last 0\n            mstore(\n                add(pointer, 194),\n                0xFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000 // 202 + 1\n            )\n\n            // hash info:\n            mstore(\n                add(pointer, 205),\n                0x3031300d06096086480165030402010500042000000000000000000000000000\n            )\n\n            // hash:\n            mstore(add(pointer, 224), hash)\n        }\n    }\n\n    /**(base ^ exponent) % modulo*/\n    function powMod2048(\n        uint256[8] memory base,\n        uint256 exponent,\n        uint256[8] memory modulus\n    ) private returns (bytes32[8] memory ret) {\n        assembly {\n            // Free memory pointer\n            let pointer := mload(0x40)\n\n            // bigExpMod contract input format:\n            // <length_of_BASE> <length_of_EXPONENT> <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>\n\n            //lengths\n            mstore(pointer, 0x100)\n            mstore(add(pointer, 0x20), 0x20)\n            mstore(add(pointer, 0x40), 0x100)\n\n            //\n\n            // Define variables base, exponent and modulus\n            mstore(add(pointer, 0x60), mload(base))\n            mstore(add(pointer, 0x80), mload(add(base, 0x20)))\n            mstore(add(pointer, 0xA0), mload(add(base, 0x40)))\n            mstore(add(pointer, 0xC0), mload(add(base, 0x60)))\n\n            mstore(add(pointer, 0x0E0), mload(add(base, 0x80)))\n            mstore(add(pointer, 0x100), mload(add(base, 0xA0)))\n            mstore(add(pointer, 0x120), mload(add(base, 0xC0)))\n            mstore(add(pointer, 0x140), mload(add(base, 0xE0)))\n\n            mstore(add(pointer, 0x160), exponent)\n\n            mstore(add(pointer, 0x180), mload(modulus))\n            mstore(add(pointer, 0x1A0), mload(add(modulus, 0x20)))\n            mstore(add(pointer, 0x1C0), mload(add(modulus, 0x40)))\n            mstore(add(pointer, 0x1E0), mload(add(modulus, 0x60)))\n\n            mstore(add(pointer, 0x200), mload(add(modulus, 0x80)))\n            mstore(add(pointer, 0x220), mload(add(modulus, 0xA0)))\n            mstore(add(pointer, 0x240), mload(add(modulus, 0xC0)))\n            mstore(add(pointer, 0x260), mload(add(modulus, 0xE0)))\n\n            // Store the result\n\n            // Call the precompiled contract 0x05 = bigModExp\n            if iszero(\n                call(\n                    gas(), //gas\n                    0x05, //bigModExp address\n                    0, //ETH value\n                    pointer, //in\n                    0x280, //in size\n                    ret, //out\n                    0x100 // out size\n                )\n            ) {\n                revert(0, 0)\n            }\n        }\n    }\n}\n\ncontract RSATest {\n    function hash(string calldata message) external pure returns (bytes32) {\n        return sha256(abi.encodePacked(message));\n    }\n\n    function pad(string calldata message)\n        external\n        pure\n        returns (bytes32[8] memory pointer)\n    {\n        return RSA.pad2048SHA256(sha256(abi.encodePacked(message)));\n    }\n\n    /** Verifies a digital signature for a string message */\n    function verifySig2048SHA256(\n        string calldata message,\n        uint256[8] memory sig,\n        uint256 exp,\n        uint256[8] memory modulus\n    ) external returns (bool) {\n        return RSA.verifySig2048SHA256(message, sig, exp, modulus);\n    }\n}\n\n\n\n\n\n\nlibrary PublicKeys {\n    /** Gets a public key params, requires that the key is enabled at dateRef time */\n    function getValidPublicKey(\n        mapping(uint16 => Types.PublicKey) storage publicKeys,\n        uint16 index,\n        uint32 dateRef\n    ) internal view returns (uint256 exp, uint256[8] memory modulus) {\n        Types.PublicKey memory r = publicKeys[index];\n        require(dateRef >= r.enableTime, \"public key not yet nabled\");\n        require(dateRef <= r.disableTime, \"public key disabled\");\n\n        return (r.exp, r.modulus);\n    }\n\n    /**\n     Add a new public keys that will be enabled after \"timeLock\" minutes\n     Does not verify \"index\", so caller needs to ensure that this is an empty index.\n     */\n    function addPublicKey(\n        mapping(uint16 => Types.PublicKey) storage publicKeys,\n        uint16 timeLock,\n        uint16 index,\n        uint256 exp,\n        uint256[8] memory modulus\n    ) external {\n        uint32 unixMinutes = uint32(block.timestamp / 60);\n        publicKeys[index] = Types.PublicKey(\n            exp,\n            modulus,\n            unixMinutes + timeLock,\n            0xFFFFFFFF\n        );\n    }\n\n    /** \n    Disables an specific public key after \"timelock\" minutes.\n     */\n    function disablePublicKey(\n        mapping(uint16 => Types.PublicKey) storage publicKeys,\n        uint16 timeLock,\n        uint16 index\n    ) external {\n        Types.PublicKey memory r = publicKeys[index];\n        uint32 unixMinutes = uint32(block.timestamp / 60);\n        uint32 disableTime = unixMinutes + timeLock;\n        require(disableTime < r.disableTime, \"key already disabled\");\n\n        publicKeys[index] = Types.PublicKey(\n            // copy:\n            r.exp,\n            r.modulus,\n            r.enableTime,\n            // update\n            disableTime\n        );\n    }\n}\n\n\n\n\nlibrary Coins {\n    function initCoins(mapping(uint16 => address) storage coins, uint16 c)\n        external\n        returns (uint16)\n    {\n        // native wrapped:\n\n        // WBNB\n        coins[c++] = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n\n        // stables:\n\n        // USDT\n        coins[c++] = address(0x55d398326f99059fF775485246999027B3197955);\n\n        // USDC\n        coins[c++] = address(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\n\n        // BUSD\n        coins[c++] = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n\n        // DAI\n        coins[c++] = address(0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3);\n\n        // USDC\n        coins[c++] = address(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\n\n        // binance pegs:\n\n        // BTC\n        coins[c++] = address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\n\n        // ETH\n        coins[c++] = address(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\n\n        // ADA\n        coins[c++] = address(0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47);\n\n        // XRP\n        coins[c++] = address(0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE);\n\n        // DOT\n        coins[c++] = address(0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402);\n\n        // LTC\n        coins[c++] = address(0x4338665CBB7B2485A8855A139b75D5e34AB0DB94);\n\n        return c;\n    }\n}\n\n\n\n\n\n\n\n\n\nlibrary Receipt {\n    /** \n        Proves that the buyer payed the seller by sending a digitally signed \"cadenaCDA\",\n        returns the verified buy amount in MXN cents\n     */\n    function getReceiptValidAmount(\n        mapping(uint16 => Types.PublicKey) storage publicKeys,\n        mapping(uint256 => Types.Order) storage orders,\n        uint256 orderIndex,\n        uint16 publicKeyIndex,\n        uint32 pubKeyDateRef,\n        uint256[8] memory sig,\n        string calldata message\n    ) internal returns (uint80) {\n        Types.Order memory order = orders[orderIndex];\n        // honor seller max pub key:\n        require(\n            publicKeyIndex <= order.maxPubKeyIndex,\n            \"seller doesn't trusts pub key\"\n        );\n\n        // verify bank signature:\n        (uint256 exp, uint256[8] memory modulus) = PublicKeys.getValidPublicKey(\n            publicKeys,\n            publicKeyIndex,\n            pubKeyDateRef\n        );\n\n        require(\n            RSA.verifySig2048SHA256(message, sig, exp, modulus),\n            \"invalid signature\"\n        );\n        (uint32 dateDays, uint48 nonce, uint160 dest, uint80 amount) = Parser\n            .parseMessage(message);\n\n        {\n            uint32 unixDays = uint32(block.timestamp / 60 / 60 / 24);\n\n            // Receipt should be up to 7 days older and  newer\n            require(\n                dateDays >= (unixDays - 7) && dateDays <= (unixDays + 7),\n                \"out of date\"\n            );\n        }\n\n        // verify seller bank account and SPEI nonce:\n        require(order.nonce == nonce && order.dest == dest, \"nonce or dest\");\n\n        return amount;\n    }\n}\n\n\n\n\n\n\nlibrary Disable {\n    function enableOrder(\n        mapping(uint256 => Types.OrderVariables) storage orderVars,\n        uint256 orderIndex\n    ) internal {\n        Types.OrderVariables memory order = orderVars[orderIndex];\n        orderVars[orderIndex] = Types.OrderVariables({\n            // copy:\n            funds: order.funds,\n            locked: order.locked,\n            expire: order.expire,\n            lockTime: order.lockTime,\n            lockRatio10000: order.lockRatio10000,\n            coinIndex: order.coinIndex,\n\n            // update:\n            disabled: false\n        });\n    }\n\n    function disableOrder(\n        mapping(uint256 => Types.OrderVariables) storage orderVars,\n        uint256 orderIndex\n    ) internal {\n        Types.OrderVariables memory order = orderVars[orderIndex];\n        orderVars[orderIndex] = Types.OrderVariables({\n            // copy:\n            funds: order.funds,\n            locked: order.locked,\n            expire: order.expire,\n            lockTime: order.lockTime,\n            lockRatio10000: order.lockRatio10000,\n            coinIndex: order.coinIndex,\n\n            // update\n            disabled: true\n        });\n    }\n}\n\n\n\n\n\n\nlibrary Creator {}\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary Funding {\n      /** Add funds to a sell order */\n    function fundOrder(\n            mapping(uint256 => Types.OrderVariables) storage orderVars,\n            mapping(uint16 => address) storage coins,\n            uint256 orderIndex, \n            uint80 amount) internal {\n        require(amount  > 0, \"amount is 0\");\n        // No need to verify that seller == msg.sender, anyone can fund an order\n        Types.OrderVariables memory order = orderVars[orderIndex];\n        \n        address coin = coins[order.coinIndex];\n        if(!IERC20(coin).transferFrom(msg.sender, address(this), uint256(amount) * 1000)) {\n            revert(\"not enough funds\");\n        }\n\n        orderVars[orderIndex] = Types.OrderVariables({\n            // copy:\n            locked: order.locked,\n            expire: order.expire,\n            disabled: order.disabled,\n            lockRatio10000: order.lockRatio10000,\n            lockTime: order.lockTime,\n            coinIndex: order.coinIndex,\n\n            // update:\n            funds: order.funds + amount\n\n        });\n    }\n\n    function defundOrder(\n            mapping(uint256 => Types.OrderVariables) storage orderVars,\n            mapping(uint16 => address) storage coins,\n            uint256 orderIndex, \n            uint80 amount\n            ) internal {\n        require(amount > 0, \"amount is zero\");\n        \n        Types.OrderVariables memory order = orderVars[orderIndex];\n        uint80 locked = Utils.getLockedAmount(order.locked, order.expire, uint32(block.timestamp / 60));\n        uint80 free = order.funds - locked;\n\n        require(amount <= free, \"amount more than free funds\");\n\n        address coin = coins[order.coinIndex];\n        if(!IERC20(coin).transfer(msg.sender, uint256(amount) * 1000)) {\n            // unreachable\n            revert(\"not enough balance in contract\");\n        }\n\n        orderVars[orderIndex] = Types.OrderVariables({\n            // copy\n            expire: order.expire,\n            lockTime: order.lockTime,\n            lockRatio10000: order.lockRatio10000,\n            disabled: order.disabled,\n            coinIndex: order.coinIndex,\n\n            // update\n            funds: order.funds - amount,\n            locked: locked\n        });\n    }\n}\n\n\nlibrary Lock {\n     /** Lock \"amount\" for the given order. Caller will pay amount * lockRatio  */\n    function lockOrder(\n        mapping(uint256 => Types.OrderVariables) storage orderVars,\n        mapping(uint16 => address) storage coins,\n        mapping(address => mapping(uint256 => Types.BuyerLock)) storage buyerLocks,\n        uint256 orderIndex, \n        uint80 amount) internal {\n        Types.OrderVariables memory order = orderVars[orderIndex];\n        require(order.lockTime > 0, \"order doesn't exists\");\n        require(!order.disabled, \"order disabled\");\n        require(amount > 0, \"amount is zero\");\n\n        address coin = coins[order.coinIndex];\n        uint32 unixMinutes = uint32(block.timestamp / 60);\n        uint80 lock =  Utils.getLockedAmount(order.locked, order.expire, unixMinutes);\n        uint80 free = order.funds - lock;\n\n        require(amount <= free, \"not enough order funds\");\n\n        // Buyer pays amount * lockRatio\n        uint80 fundsDelta = Utils.mulRatio(amount, order.lockRatio10000, 10000);\n        if(fundsDelta > 0) {\n            if(!IERC20(coin).transferFrom(msg.sender, address(this), uint256(fundsDelta) * 1000)) {\n                revert(\"not enough funds\");\n            }\n        }\n\n        // Increment order funds and lock:\n\n        uint32 expire = unixMinutes + order.lockTime;\n        orderVars[orderIndex] = Types.OrderVariables({\n            // copy:\n            lockRatio10000: order.lockRatio10000,\n            lockTime: order.lockTime,\n            coinIndex: order.coinIndex,\n            disabled: false,\n\n            // update:\n            funds: order.funds + fundsDelta,\n            locked: lock + fundsDelta + amount,\n            expire: expire\n        });\n\n        // Increment buyer lock:\n        Types.BuyerLock memory buyerLock = buyerLocks[msg.sender][orderIndex];\n        uint80 bLock =  Utils.getLockedAmount(buyerLock.amount, buyerLock.expire, unixMinutes);\n        buyerLocks[msg.sender][orderIndex] = Types.BuyerLock({\n            amount: bLock + fundsDelta + amount,\n            expire: expire,\n            publicKeyDateRef: unixMinutes\n        });\n    }\n    \n \n}\n\n\n\n\n\n\n\n\n\ncontract SPEI {\n    event OrderCreated(uint256 index, address indexed seller);\n    event BuyExecuted(uint80 amount);\n    event OrderLocked(uint256 index, address indexed buyer);\n\n    /** \n\n    ************************************************************************\n    |  Feel free to buy me a cup of coffee by donating to this address :)  |\n    ************************************************************************\n\n     */\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n        initCoins();\n    }\n\n    // ***********************************\n    // owner functions:\n    // ***********************************\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"owner only\");\n        _;\n    }\n\n    function initCoins() private onlyOwner {\n        require(coinCount == 0, \"coins already initted\");\n\n        uint16 c = Coins.initCoins(coins, coinCount);\n        coinCount = c;\n    }\n\n    function addCoin(address coin) external onlyOwner {\n        require(coinCount > 0, \"call initCoins\");\n        coins[coinCount] = coin;\n        coinCount++;\n    }\n\n    function requestTimelockChange() external onlyOwner {\n        uint32 unixMinutes = uint32(block.timestamp / 60);\n        timeLockChangeEnabledAt = unixMinutes + timeLock;\n    }\n\n    /** Send collected fees to owner */\n    function collectFees(address coin) external onlyOwner {\n        uint256 balance = ownerFees[coin];\n        require(balance > 0);\n\n        if (!IERC20(coin).transfer(owner, uint256(balance) * 1000)) {\n            revert(\"not enough funds\");\n        }\n        ownerFees[coin] -= balance;\n    }\n\n    modifier onlyOwnerInTimelock() {\n        require(msg.sender == owner);\n        {\n            uint32 unixMinutes = uint32(block.timestamp / 60);\n            require(\n                unixMinutes >= timeLockChangeEnabledAt &&\n                    unixMinutes < (timeLockChangeEnabledAt + 60 * 3),\n                \"timelock only\"\n            );\n        }\n        _;\n    }\n\n    function changeOwner(address next) external onlyOwnerInTimelock {\n        owner = next;\n    }\n\n    function changeTimelock(uint16 newTimelock) external onlyOwnerInTimelock {\n        // Max timelock is 1 week\n        require(newTimelock < 60 * 24 * 7);\n        require(fixedTimeLock == false);\n\n        timeLock = newTimelock;\n    }\n\n    function changeFee(uint8 newFee) external onlyOwnerInTimelock {\n        ownerFeeRatio = newFee;\n    }\n\n    /** Adds a new bank public key that will be enabled after \"timeLock\" minutes */\n    function addPublicKey(uint256 exp, uint256[8] memory modulus)\n        external\n        onlyOwner\n    {\n        uint16 index = publicKeyCount;\n        PublicKeys.addPublicKey(publicKeys, timeLock, index, exp, modulus);\n        publicKeyCount = index + 1;\n    }\n\n    /** Disables a public key after \"timeLock\" minutes */\n    function disablePublicKey(uint16 index) external onlyOwner {\n        PublicKeys.disablePublicKey(publicKeys, timeLock, index);\n    }\n\n    /** Disables the ability to change the timelock */\n    function fixTimelock() external onlyOwner {\n        fixedTimeLock = true;\n    }\n\n    /** Time required for owner to update public keys in minutes */\n    uint16 public timeLock;\n    /** timeLock and owner fee will be able change in the range [timeLockChangeEnabledAt, timeLockChangeEnabledAt + 3 hours] */\n    uint32 public timeLockChangeEnabledAt;\n\n    /** Prevents the timelock to be changed */\n    bool public fixedTimeLock;\n\n    /** \n        Owner fee for any executed buys in 0.1% steps,\n        so max fee == 25.6%\n        Fee can only be changed inside the timelock period\n     */\n    uint8 public ownerFeeRatio;\n\n    /** Collected fees for each ERC20 coin */\n    mapping(address => uint256) public ownerFees;\n\n    /** For each order, the seller address */\n    mapping(uint256 => address) internal orderSellers;\n\n    /** All sell orders */\n    mapping(uint256 => Types.Order) internal orders;\n\n    /** Order variable data */\n    mapping(uint256 => Types.OrderVariables) internal orderVars;\n\n    /** For each buyer and order, the locked funds */\n    mapping(address => mapping(uint256 => Types.BuyerLock)) internal buyerLocks;\n\n    /** Public keys count, also the next public key index */\n    uint16 internal publicKeyCount;\n\n    /** Bank public keys */\n    mapping(uint16 => Types.PublicKey) internal publicKeys;\n\n    /** \n        Least significant 256 bits of already spent message signatures \n        Note that we didn't found a way to prevent double spending without tracking each receipt separately,\n        this is an open problem that might be related to a secure way to generate random and non repeatable SPEI nonces\n    */\n    mapping(uint256 => bool) internal spentSignatures;\n\n    /** coin address index */\n    mapping(uint16 => address) internal coins;\n    uint16 internal coinCount;\n\n    function orderSeller(uint256 index) external view returns (address) {\n        return orderSellers[index];\n    }\n\n    function getCoinCount() external view returns (uint16) {\n        return coinCount;\n    }\n\n    function getCoin(uint16 index) external view returns (address) {\n        return coins[index];\n    }\n\n    function orderDefinition(uint256 index)\n        external\n        view\n        returns (Types.Order memory)\n    {\n        return orders[index];\n    }\n\n    function orderVariables(uint256 index)\n        external\n        view\n        returns (Types.OrderVariables memory)\n    {\n        return orderVars[index];\n    }\n\n    function buyerLock(address buyer, uint256 order)\n        external\n        view\n        returns (Types.BuyerLock memory)\n    {\n        return buyerLocks[buyer][order];\n    }\n\n    function getPublicKeyCount() external view returns (uint16) {\n        return publicKeyCount;\n    }\n\n    function getValidPublicKey(uint16 orderIndex)\n        external\n        view\n        returns (uint256 exp, uint256[8] memory modulus)\n    {\n        return\n            PublicKeys.getValidPublicKey(\n                publicKeys,\n                orderIndex,\n                uint32(block.timestamp / 60)\n            );\n    }\n\n    function getPublicKey(uint16 index)\n        external\n        view\n        returns (Types.PublicKey memory)\n    {\n        return publicKeys[index];\n    }\n\n    function getOwnerFees(address coin) external view returns (uint256) {\n        return ownerFees[coin];\n    }\n\n    /** Creates a sell order and returns the order index. Caller must pay \"funds\" in \"coin\" */\n    function createOrder(\n        uint256 index,\n        uint80 funds,\n        uint160 dest,\n        uint16 coinIndex,\n        uint16 priceMXN1000Num,\n        uint16 priceMXN1000Den,\n        uint48 nonce,\n        uint16 lockRatio10000,\n        uint16 lockTime,\n        uint16 maxPubKeyIndex\n    ) external returns (uint256) {\n        require(priceMXN1000Num > 0, \"price num\");\n        require(priceMXN1000Den > 0, \"price den\");\n        require(lockTime > 0, \"lockTime is 0\");\n\n        // Can't overwrite orders:\n        require(orderSellers[index] == address(0), \"order already exists\");\n\n        if (funds > 0) {\n            address coin = coins[coinIndex];\n            require(coin != address(0), \"invalid coin\");\n\n            if (\n                !IERC20(coin).transferFrom(\n                    msg.sender,\n                    address(this),\n                    uint256(funds) * 1000\n                )\n            ) {\n                revert(\"not enough funds\");\n            }\n        }\n\n        orderSellers[index] = msg.sender;\n\n        orders[index] = Types.Order({\n            dest: dest,\n            nonce: nonce,\n            priceMXN1000Num: priceMXN1000Num,\n            priceMXN1000Den: priceMXN1000Den,\n            maxPubKeyIndex: maxPubKeyIndex\n        });\n\n        orderVars[index] = Types.OrderVariables({\n            funds: funds,\n            locked: 0,\n            expire: 0,\n            disabled: false,\n            lockRatio10000: lockRatio10000,\n            lockTime: lockTime,\n            coinIndex: coinIndex\n        });\n\n        emit OrderCreated(index, msg.sender);\n\n        return index;\n    }\n\n    /** Add funds to a sell order. Anyone can fund an order */\n    function fundOrder(uint256 orderIndex, uint80 amount) external {\n        Funding.fundOrder(orderVars, coins, orderIndex, amount);\n    }\n\n    /** Withdraw funds from a sell order */\n    function defundOrder(uint256 orderIndex, uint80 amount) external {\n        address seller = orderSellers[orderIndex];\n        require(seller == msg.sender);\n\n        return Funding.defundOrder(orderVars, coins, orderIndex, amount);\n    }\n\n    /** Prevent any buyer from locking this order */\n    function disableOrder(uint256 orderIndex) external {\n        require(orderSellers[orderIndex] == msg.sender);\n        Disable.disableOrder(orderVars, orderIndex);\n    }\n\n    /** Allow again buyers to lock this order */\n    function enableOrder(uint256 orderIndex) external {\n        require(orderSellers[orderIndex] == msg.sender);\n        Disable.enableOrder(orderVars, orderIndex);\n    }\n\n    /** Lock \"amount\" for the given order. Caller will pay amount * lockRatio  */\n    function lockOrder(uint256 orderIndex, uint80 amount) external {\n        Lock.lockOrder(orderVars, coins, buyerLocks, orderIndex, amount);\n        emit OrderLocked(orderIndex, msg.sender);\n    }\n\n    /** Executes an already verified buy */\n    function executeBuy(\n        uint256 orderIndex,\n        uint80 amountMXN,\n        Types.BuyerLock memory lock\n    ) internal {\n        Types.Order memory order = orders[orderIndex];\n        uint80 amount = Buy.executeBuy(\n            orderVars,\n            ownerFees,\n            coins,\n            buyerLocks,\n            lock,\n            orderIndex,\n            amountMXN,\n            order.priceMXN1000Num,\n            order.priceMXN1000Den,\n            ownerFeeRatio\n        );\n\n        emit BuyExecuted(amount);\n    }\n\n    /** Buys a sell order */\n    function buy(\n        uint256 orderIndex,\n        uint16 publicKeyIndex,\n        uint256[8] memory sig,\n        string calldata message\n    ) external {\n        Types.BuyerLock memory lock = buyerLocks[msg.sender][orderIndex];\n\n        uint80 amountMXN = Receipt.getReceiptValidAmount(\n            publicKeys,\n            orders,\n            orderIndex,\n            publicKeyIndex,\n            lock.publicKeyDateRef,\n            sig,\n            message\n        );\n        require(!spentSignatures[sig[3]], \"already spent\");\n        executeBuy(orderIndex, amountMXN, lock);\n        spentSignatures[sig[3]] = true;\n    }\n}\n\ncontract SPEITest is SPEI {\n    function executeBuyTest(uint256 orderIndex, uint80 amountMXN) external {\n        Types.BuyerLock memory lock = buyerLocks[msg.sender][orderIndex];\n        executeBuy(orderIndex, amountMXN, lock);\n    }\n}\n\n\n\n"